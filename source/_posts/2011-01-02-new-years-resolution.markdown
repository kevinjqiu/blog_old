---
layout: post
title: "New Year's Resolution"
date: 2011-01-02 19:47
comments: true
categories: personal
---

2011 here we come! In the spirit of continual learning, I'm going to write down the technology I'd love to learn this year.

## [Haskell](http://haskell.org")

Now that I'm more interested in functional languages, I'd love to look into this "pure" functional language that inspired countless other ones of its kind.

## [Lift](http://liftweb.net)

Last year I scratched the surface of [Scala](http://www.scala-lang.org), a hybrid JVM language. I'm very fond of it, and think it has tremendous potential. Twitter and FourSquare are already using Scala, so it has been put to the test of some pretty high-profile usages.  Lift is the most popular web framework built on top of Scala. It claims to have the rapid application development benefits from Rails and the benefits from statically typed language. 

## More advanced features of [Clojure](http://clojure.org)

In the past two years, I explored Clojure and on off. I love the Lisp idea of [homoiconicity](http://en.wikipedia.org/wiki/Homoiconicity) which unifies programming and meta-programming. That said, I haven't been using macro in Clojure too much, and there are other cool ideas of Clojure I haven't been able to explore deeply, such as protocols and [software transactional memory](http://en.wikipedia.org/wiki/Software_transactional_memory)

## [Ruby](http://www.ruby-lang.org/en/) and [Rails](http://rubyonrails.org/)

For the past few years, I've been refraining myself from learning Ruby, because I'm already quite adept at Python, and I feel I should be learning languages that are different from what I already know. However, the more I heard about Ruby and its ideas, the more interesting it appears to me. On top of that, Rails 3 has come out, and it appears to have improved significantly. Moreover, there are a lot of advancement in the Ruby VM world such as JRuby, which means Ruby applications don't have to run on the old and dreadful (hear-say) MRI. I wouldn't mind taking Ruby and Rails out for a spin this year.

## [Android](http://www.android.com/)

Last year I got an HTC Legend Android phone, with the intention of developing for Android at some point of time. It didn't work out that way, though, but Android continues to be a very interesting and fast growing platform. Mobile *is* the future, and I'd like to poke into the Android world this year, primarily because it's open source. iOS is equally interesting technically, but I don't own a Mac and I don't like the idea of paying Apple $99 for SDK even though I don't intend to publish on AppStore.

I think that's enough for a year...or is it? There's a few more technologies I wish to learn or keep up with:

## GWT and Google App Engine

2 years of professional GWT development made me a firm fan of this Google technology. I got out of GWT for different reasons, but I love the engineering effort they put into GWT. It may not take over the world but it's definitely a solid player in the front-end web development arena. Especially now they integrated with the Spring framework and made deploying to App Engine easy, it may pick up more traction this year. I think the Java language is both the pros and cons of GWT. I'd love to see an alternative language (Scala) being implemented for GWT, but it may not happen any time soon.

## A "NoSQL" database

Let's face it, "NoSQL" is a terrible name, but it grabs people's attention. I flirted with [CouchDB](http://couchdb.apache.org/) briefly last year, and would love to continue this journey this year. Also, [MongoDB](http://www.mongodb.org/) seems interesting too.

## Node.js

It's the least I think I'd learn this year. It's hot in the geekdom right now, and it has its value, for example, having both the server and client side written in Javascript eliminates the need to implement the validation logic in two different languages. However, I'm just not a big fan of Javascript. I think it's a language that's by a chain of serendipitous events became the world's most widely used language. It carries a huge historical burden, and although it has cool features, some other modern languages have them too and do better. Regardless, given the stardom status of Node.js, it deserves some looking into :)



