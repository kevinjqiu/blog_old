---
layout: post
title: "Writing a Simple Clojure Library"
date: 2012-03-03 20:25
comments: true
categories: clojure
---

I've been learning/using Clojure on and off for about 2 years. The lispy syntax isn't a deterrent for me at all, in fact, I'm quite fond of it and consider it very [elegant](http://en.wikipedia.org/wiki/Homoiconicity). However, it does take some time to get used to. I don't use Clojure or anything remotely close in my day job, but I love to find something useful to implement using Clojure. In the past few days I found such niche.

## Terminal colours

Ever wonder how some console applications can output coloured text? Most terminals and terminal emulators (think iTerm or konsole) support colour through a system of [escape sequences](http://en.wikipedia.org/wiki/ANSI_escape_code).

An Escape Sequence starts with the ASCII code for the escape character (0x1b or 33). There a list of control characters you can specify after the escape character that controls the colour and style of the text after it. For example, sending "[31mfoo" to a terminal means "output red coloured text from now on". Everything the terminal output will be coloured red, until the terminal reads another escape sequence, including "[ESC]0m", which tells the terminal to reset the styles to the default.

So I had this idea to implement this in Clojure as a library so that console application authors can use it to output stylized text from their application using idiomatic Clojure, and here comes [Lumiere](https://github.com/kevinjqiu/lumiere).

## Implementing it in Clojure

### Design the interface

What's our end goal here? We would like to output colour sequence wrapped text with Clojure function calls such as

```clojure
(red "foo") ; output foo in red colour
(bg-green "bar") ;"bar" with green background colour
(bold (magenta "nyan cat")) ; bold and magenta
(-> "nyan cat" red bg-white bold) ; use Clojure's "thread macro" to combine these functions, resulting in red foreground, white background and bold "nyan cat"
```

### Toolchain

I wrote a [blog post](/2011/02/11/cake-the-yummy-clojure-build-system/) a year ago about how I liked Cake the Clojure build system alternative to the defacto Leiningen. The recent news on this is that Cake and Leiningen are merging. This time, I decided to use Leiningen from the start. Even though Leiningen hasn't ported some of the Cake goodies, but I'm hoping they will get ported soon.

### First working version:

With `lein new lumiere`, Leiningen generates the default project layout. By default, Leiningen generates `src/lumiere/core.clj` and `test/lumiere/core.clj`. Because Lumiere is such a small script, we don't need the `'lumiere.core` namespace, rather I'd like the functions to be in the `'lumiere` namespace. The easiest way is to delete `src/lumiere/` folder and create `lumiere.clj` under src. Same goes for the test file.

Following the spirit of TDD, off I went to write my first test:

```clojure
(ns lumiere.test
  (:use [lumiere])
  (:use [clojure.test]))

(deftest test-only-foreground
  (is (= "&#092;&#048;33[30msome black text&#092;&#048;33[0m" (black "some black test"))))
```

This tests that the correct sequences of characters are generated by the call to `(black "...")`. 33 is the ASCII code for .

To make this test pass, I added this in `src/lumiere.clj`, 

```clojure
(ns lumiere)
(defn black [text]
  (format "&#092;&#048;33[0m" 30 text)) ; 30 is the code for black foreground.
```

This passes the tests, but obviously there's room for abstraction:
* the red foreground code is 31, green 32, etc...
* the black background code is 40, red 41, green 42, etc...

So here we go:
```clojure
(defn- colour ; defn- makes this function private to the current namespace.
  ([code is-bg?] (format "&#092;&#048;33[%dm" (+ (if is-bg? 40 30) code)))
  ([code] (colour code false)))

(defn black [text] (colour 0))
(defn red [text] (colour 1))
(defn bg-black [text] (colour 0 true))
(defn bg-red [text] (colour 1 true))
```

Clojure supports "default" arguments through method overloading. Here we adjust the offset based on whether or not that colour is a foreground or background.

### Second take: use macro to define declaratively create colour functions

One advantage of lispy syntax is the convergence of programming with meta-programming. If you read the core Clojure library code, you'll find that Clojure defines a few special forms and most control structures are written in macros. In my case, however, I'm using macros to define colour/style functions in a declarative way. Some may argue it doesn't justify using macro for this purpose, but I just want to practice writing macros, and it does make the public interface of the library a bit prettier.

First off, again, we need to define what the end result should look like. I would still like the functions to remain the same, e.g., red, bg-red, black, bg-black, etc. However, defining these functions takes a lot of boilerplate code. I'd like to simply call `(defcolour BLACK 0)` or the like to generate the `black` and `bg-black` functions for me.

Disclaimer: I'm a novice macro writer. Advanced readers, please hold your nose and tell me what I did wrong or any improvements could be made :)

```clojure
(def RESET "&#092;&#048;33[0m")
(defmacro defcolour [colour-func-name bg-colour-func-name colour-code]
  `(do
    (defn ~colour-func-name [text#]
      (format "%s%s%s" (colour ~colour-code) text# RESET))
    (defn ~bg-colour-func-name [text#]
      (format "%s%s%s" (colour ~bg-colour-code true) text# RESET))))

(defcolour black bg-black 0)
(defcolour red bg-red 1)
(defcolour green bg-green 2)
; etc...
```

A few special reader macros you need to know about when writing a macro:
* tick (`) indicates the following code should be quoted and treated as a template.
* tilda (~) indicates that the symbol should not be quoted (unquote), and should be replaced with the value in the current context.
* hash (#) indicates that the macro system should generate a unique name for this symbol so it doesn't conflict. Otherwise, it will be expanded to its fully qualified name.

Run tests and because we didn't change our public interface, everything all tests should still pass.

###  Take 3: combining styles

Alright, now that we have a fully functional style system, we can cascade the styles, e.g., `(red (bg-green "foo"))`. It work as expected when trying it in a REPL, but the character sequence it generates is "33[31m33[42mfoo33[0m33[0m" and surely it isn't optimal. If we want to add styles such as bold, it's going to get even worse.

So, we need some abstraction here. When you call `(red "some text")` it shouldn't generate the character sequence right away. Instead, the caller should decide when the sequence should be generated. We need some data structure to represent a "luminated" text. In Clojure we can define a "record".

```clojure
(defrecord Lumiere [text opts])
```

`opts` is a map with keys `:fg`, `:bg`, `:styles`. We also want to override the `toString()` method so when the user calls `(str lumiered-text)`, he will get the character sequence ready to be printed to the console. The downside of this is that we modified the interface, so we need to go back and change the tests so they call `(str (red "foo"))`:

```clojure
  (is (= "&#092;&#048;33[30msome black text&#092;&#048;33[0m" (str (black "some black test")))))
```

To override `toString()`, we need to extend our Lumiere type to conform to the `IObject` protocol:

```clojure
(defn- ansi-escape-seq [& codes]
  (format "&#092;&#048;33[%sm" (join ";" (filter #(not= % nil) codes))))

(defrecord Lumiere [text fg bg styles]
  Object
  (toString [this]
    (let [prefix (ansi-escape-seq (:fg this) (:bg this) (:styles this))]
      (format "%s%s%s" prefix (:text this) RESET))))
```

Next we need to let the colour/style functions return Lumiere object, rather than plain character sequence. There are two situations we need to adapt:

1. When we first start decorating a text, text input is going to be a plain string. In this case, we need to create a Lumiere object with the text and options.
2. When the return of a colour/style function is chained into another colour/style function, we need to modify the options of the Lumiere object.

```clojure
(defn- adapt-lum [text option value]
  (let [local-option-map (merge {:fg nil :bg nil :styles nil} {option value})]
    (cond
      (instance? String text) (Lumiere. text (:fg local-option-map) (:bg local-option-map) (:styles local-option-map))
      (instance? Lumiere text) (assoc text option value)
      :else (throw (java.lang.IllegalArgumentException.)))))
```

and we need to modify the macros so `adapt-lum` helper is used:

```clojure
(defmacro defcolour [colour-func-name bg-colour-func-name ^Integer colour-code]
  `(do
     (defn ~colour-func-name [text#]
       (adapt-lum text# :fg ~colour-name))
     (defn ~bg-colour-func-name [text#]
       (adapt-lum text# :bg ~bg-colour-name))))
```

## Publish to Clojar.org

Now that the library is in a relatively stable state. I'd like to publish this snapshot version to a repository. Clojars.org is the most popular clojure library repository. Register on clojars.org, add let them know your public key. Then do `lein pom && lein deploy`, voil√†!

