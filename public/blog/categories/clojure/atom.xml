<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Reminiscential: of or pertaining to rememberance]]></title>
  <link href="http://kevinjqiu.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://kevinjqiu.github.com/"/>
  <updated>2013-11-20T13:44:10-05:00</updated>
  <id>http://kevinjqiu.github.com/</id>
  <author>
    <name><![CDATA[Kevin Jing Qiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing a Simple Clojure Library]]></title>
    <link href="http://kevinjqiu.github.com/2012/03/03/writing-a-simple-clojure-library/"/>
    <updated>2012-03-03T20:25:00-05:00</updated>
    <id>http://kevinjqiu.github.com/2012/03/03/writing-a-simple-clojure-library</id>
    <content type="html"><![CDATA[<p>I've been learning/using Clojure on and off for about 2 years. The lispy syntax isn't a deterrent for me at all, in fact, I'm quite fond of it and consider it very <a href="http://en.wikipedia.org/wiki/Homoiconicity">elegant</a>. However, it does take some time to get used to. I don't use Clojure or anything remotely close in my day job, but I love to find something useful to implement using Clojure. In the past few days I found such niche.</p>

<h2>Terminal colours</h2>

<p>Ever wonder how some console applications can output coloured text? Most terminals and terminal emulators (think iTerm or konsole) support colour through a system of <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">escape sequences</a>.</p>

<p>An Escape Sequence starts with the ASCII code for the escape character (0x1b or 33). There a list of control characters you can specify after the escape character that controls the colour and style of the text after it. For example, sending "[31mfoo" to a terminal means "output red coloured text from now on". Everything the terminal output will be coloured red, until the terminal reads another escape sequence, including "[ESC]0m", which tells the terminal to reset the styles to the default.</p>

<p>So I had this idea to implement this in Clojure as a library so that console application authors can use it to output stylized text from their application using idiomatic Clojure, and here comes <a href="https://github.com/kevinjqiu/lumiere">Lumiere</a>.</p>

<h2>Implementing it in Clojure</h2>

<h3>Design the interface</h3>

<p>What's our end goal here? We would like to output colour sequence wrapped text with Clojure function calls such as</p>

<p><code>clojure
(red "foo") ; output foo in red colour
(bg-green "bar") ;"bar" with green background colour
(bold (magenta "nyan cat")) ; bold and magenta
(-&gt; "nyan cat" red bg-white bold) ; use Clojure's "thread macro" to combine these functions, resulting in red foreground, white background and bold "nyan cat"
</code></p>

<h3>Toolchain</h3>

<p>I wrote a <a href="/2011/02/11/cake-the-yummy-clojure-build-system/">blog post</a> a year ago about how I liked Cake the Clojure build system alternative to the defacto Leiningen. The recent news on this is that Cake and Leiningen are merging. This time, I decided to use Leiningen from the start. Even though Leiningen hasn't ported some of the Cake goodies, but I'm hoping they will get ported soon.</p>

<h3>First working version:</h3>

<p>With <code>lein new lumiere</code>, Leiningen generates the default project layout. By default, Leiningen generates <code>src/lumiere/core.clj</code> and <code>test/lumiere/core.clj</code>. Because Lumiere is such a small script, we don't need the <code>'lumiere.core</code> namespace, rather I'd like the functions to be in the <code>'lumiere</code> namespace. The easiest way is to delete <code>src/lumiere/</code> folder and create <code>lumiere.clj</code> under src. Same goes for the test file.</p>

<p>Following the spirit of TDD, off I went to write my first test:</p>

<p>```clojure
(ns lumiere.test
  (:use [lumiere])
  (:use [clojure.test]))</p>

<p>(deftest test-only-foreground
  (is (= "&#092;&#048;33[30msome black text&#092;&#048;33[0m" (black "some black test"))))
```</p>

<p>This tests that the correct sequences of characters are generated by the call to <code>(black "...")</code>. 33 is the ASCII code for .</p>

<p>To make this test pass, I added this in <code>src/lumiere.clj</code>,</p>

<p><code>clojure
(ns lumiere)
(defn black [text]
  (format "&amp;#092;&amp;#048;33[0m" 30 text)) ; 30 is the code for black foreground.
</code></p>

<p>This passes the tests, but obviously there's room for abstraction:
* the red foreground code is 31, green 32, etc...
* the black background code is 40, red 41, green 42, etc...</p>

<p>So here we go:
```clojure
(defn- colour ; defn- makes this function private to the current namespace.
  ([code is-bg?] (format "&#092;&#048;33[%dm" (+ (if is-bg? 40 30) code)))
  ([code] (colour code false)))</p>

<p>(defn black [text] (colour 0))
(defn red [text] (colour 1))
(defn bg-black [text] (colour 0 true))
(defn bg-red [text] (colour 1 true))
```</p>

<p>Clojure supports "default" arguments through method overloading. Here we adjust the offset based on whether or not that colour is a foreground or background.</p>

<h3>Second take: use macro to define declaratively create colour functions</h3>

<p>One advantage of lispy syntax is the convergence of programming with meta-programming. If you read the core Clojure library code, you'll find that Clojure defines a few special forms and most control structures are written in macros. In my case, however, I'm using macros to define colour/style functions in a declarative way. Some may argue it doesn't justify using macro for this purpose, but I just want to practice writing macros, and it does make the public interface of the library a bit prettier.</p>

<p>First off, again, we need to define what the end result should look like. I would still like the functions to remain the same, e.g., red, bg-red, black, bg-black, etc. However, defining these functions takes a lot of boilerplate code. I'd like to simply call <code>(defcolour BLACK 0)</code> or the like to generate the <code>black</code> and <code>bg-black</code> functions for me.</p>

<p>Disclaimer: I'm a novice macro writer. Advanced readers, please hold your nose and tell me what I did wrong or any improvements could be made :)</p>

<p><code>``clojure
(def RESET "&amp;#092;&amp;#048;33[0m")
(defmacro defcolour [colour-func-name bg-colour-func-name colour-code]
 </code>(do</p>

<pre><code>(defn ~colour-func-name [text#]
  (format "%s%s%s" (colour ~colour-code) text# RESET))
(defn ~bg-colour-func-name [text#]
  (format "%s%s%s" (colour ~bg-colour-code true) text# RESET))))
</code></pre>

<p>(defcolour black bg-black 0)
(defcolour red bg-red 1)
(defcolour green bg-green 2)
; etc...
```</p>

<p>A few special reader macros you need to know about when writing a macro:
* tick (`) indicates the following code should be quoted and treated as a template.
* tilda (~) indicates that the symbol should not be quoted (unquote), and should be replaced with the value in the current context.
* hash (#) indicates that the macro system should generate a unique name for this symbol so it doesn't conflict. Otherwise, it will be expanded to its fully qualified name.</p>

<p>Run tests and because we didn't change our public interface, everything all tests should still pass.</p>

<h3>Take 3: combining styles</h3>

<p>Alright, now that we have a fully functional style system, we can cascade the styles, e.g., <code>(red (bg-green "foo"))</code>. It work as expected when trying it in a REPL, but the character sequence it generates is "33[31m33[42mfoo33[0m33[0m" and surely it isn't optimal. If we want to add styles such as bold, it's going to get even worse.</p>

<p>So, we need some abstraction here. When you call <code>(red "some text")</code> it shouldn't generate the character sequence right away. Instead, the caller should decide when the sequence should be generated. We need some data structure to represent a "luminated" text. In Clojure we can define a "record".</p>

<p><code>clojure
(defrecord Lumiere [text opts])
</code></p>

<p><code>opts</code> is a map with keys <code>:fg</code>, <code>:bg</code>, <code>:styles</code>. We also want to override the <code>toString()</code> method so when the user calls <code>(str lumiered-text)</code>, he will get the character sequence ready to be printed to the console. The downside of this is that we modified the interface, so we need to go back and change the tests so they call <code>(str (red "foo"))</code>:</p>

<p><code>clojure
  (is (= "&amp;#092;&amp;#048;33[30msome black text&amp;#092;&amp;#048;33[0m" (str (black "some black test")))))
</code></p>

<p>To override <code>toString()</code>, we need to extend our Lumiere type to conform to the <code>IObject</code> protocol:</p>

<p>```clojure
(defn- ansi-escape-seq [&amp; codes]
  (format "&#092;&#048;33[%sm" (join ";" (filter #(not= % nil) codes))))</p>

<p>(defrecord Lumiere [text fg bg styles]
  Object
  (toString [this]</p>

<pre><code>(let [prefix (ansi-escape-seq (:fg this) (:bg this) (:styles this))]
  (format "%s%s%s" prefix (:text this) RESET))))
</code></pre>

<p>```</p>

<p>Next we need to let the colour/style functions return Lumiere object, rather than plain character sequence. There are two situations we need to adapt:</p>

<ol>
<li>When we first start decorating a text, text input is going to be a plain string. In this case, we need to create a Lumiere object with the text and options.</li>
<li>When the return of a colour/style function is chained into another colour/style function, we need to modify the options of the Lumiere object.</li>
</ol>


<p>```clojure
(defn- adapt-lum [text option value]
  (let [local-option-map (merge {:fg nil :bg nil :styles nil} {option value})]</p>

<pre><code>(cond
  (instance? String text) (Lumiere. text (:fg local-option-map) (:bg local-option-map) (:styles local-option-map))
  (instance? Lumiere text) (assoc text option value)
  :else (throw (java.lang.IllegalArgumentException.)))))
</code></pre>

<p>```</p>

<p>and we need to modify the macros so <code>adapt-lum</code> helper is used:</p>

<p><code>``clojure
(defmacro defcolour [colour-func-name bg-colour-func-name ^Integer colour-code]
 </code>(do</p>

<pre><code> (defn ~colour-func-name [text#]
   (adapt-lum text# :fg ~colour-name))
 (defn ~bg-colour-func-name [text#]
   (adapt-lum text# :bg ~bg-colour-name))))
</code></pre>

<p>```</p>

<h2>Publish to Clojar.org</h2>

<p>Now that the library is in a relatively stable state. I'd like to publish this snapshot version to a repository. Clojars.org is the most popular clojure library repository. Register on clojars.org, add let them know your public key. Then do <code>lein pom &amp;&amp; lein deploy</code>, voilà!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cake - the yummy Clojure build system]]></title>
    <link href="http://kevinjqiu.github.com/2011/02/11/cake-the-yummy-clojure-build-system/"/>
    <updated>2011-02-11T19:56:00-05:00</updated>
    <id>http://kevinjqiu.github.com/2011/02/11/cake-the-yummy-clojure-build-system</id>
    <content type="html"><![CDATA[<p>About 10 minutes ago I heard about <a href="https://github.com/ninjudd/cake">cake</a> clojure build system, and gave it a try. And 10 minutes later, it won me over! Wow, it addresses all the pain points of <a href="https://github.com/technomancy/leiningen">leiningen</a>.</p>

<h2>BLAZINGLY FAST!!!</h2>

<p>Sorry for using all CAPS but I'm very excited about this improvement over leiningen -- OK, it may not be the fault of leiningen that JVM cold startup time is non-trivial but hey, someone came up with an idea of having a long running JVM process in the background, so subsequent clojure tasks reuse the same JVM instance. Cake folks integrated that nicely. It takes about 10-15 seconds to boot up a JVM but subsequent cake tasks or execution of clojure code is virtually instant! Comparing to leiningen, which doesn't take this approach and every single task (such as common ones like lein test) takes around 5 seconds. This adds up quickly and makes you less efficient. The speed improvement alone is enough for me to switch to cake.</p>

<h2>Advanced REPL functionalities: tab completion, history</h2>

<p>It just works. Very useful for having instant feedbacks while exploring the language and API. No more manually adding jLine to your classpath or hack around tab completion wrapper...It just works! (I know I said it already)</p>

<h2>run clojure files directly</h2>

<p>OK, leiningen can do this too, but through <a href="https://github.com/sids/lein-run">plugin</a>. I feel this is a very handy functionality, which probably should be included in the core.</p>

<h2>autotest</h2>

<p>Detects your code change and automatically run your test suites! Sweet.</p>

<h2>compatible with leiningen project definition files</h2>

<p>Cake understand <code>project.clj</code>, so I don't need to do anything for my existing leiningen projects. Change directory to the project and <code>cake</code> away :D</p>

<p>Overall, it just works out of the box. No more mucking around with dev-dependencies and other chores and let you focus on what you'd love to do.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up a Clojure Project with Maven]]></title>
    <link href="http://kevinjqiu.github.com/2009/11/11/setting-up-a-clojure-project-with-maven/"/>
    <updated>2009-11-11T11:00:00-05:00</updated>
    <id>http://kevinjqiu.github.com/2009/11/11/setting-up-a-clojure-project-with-maven</id>
    <content type="html"><![CDATA[<p>In this blog post I’m going to record my recent experience in setting up a Clojure project using the <a href="http://github.com/talios/clojure-maven-plugin">clojure-maven-plugin</a>.</p>

<h2>Clojure-Maven-Plugin</h2>

<p>First you need to compile the plugin from source:</p>

<p><code>
git clone git://github.com/talios/clojure-maven-plugin.git
cd clojure-maven-plugin
mvn install
</code></p>

<p>Of course, you will need to have Maven2 installed already.</p>

<p>After that, the compiled plugin jar will be in your maven local repository. Create a <code>pom.xml</code> file to use the plugin. I’m using the pom.xml from my project <a href="http://github.com/kevinjqiu/pci-clj">Programming Collective Intelligence</a> as an example:</p>

<p>```xml
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p>

<pre><code>xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;pci&lt;/groupId&gt;
&lt;artifactId&gt;pci&lt;/artifactId&gt;
&lt;name&gt;Programming Collective Intelligence&lt;/name&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.theoryinpractise&lt;/groupId&gt;
            &lt;artifactId&gt;clojure-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p></project>
```</p>

<p>Also, setting up clojure-lang and clojure-contrib (optional, but nice to have) as dependencies as follows:</p>

<p>```xml
<dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.clojure&lt;/groupId&gt;
    &lt;artifactId&gt;clojure-lang&lt;/artifactId&gt;
    &lt;version&gt;1.1.0-alpha-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.clojure&lt;/groupId&gt;
    &lt;artifactId&gt;clojure-contrib&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p></dependencies>
```</p>

<p>Clojure builds haven’t reached Maven central repository yet, so you need to build Clojure from source, and install it into your local repository by using</p>

<p><code>bash
mvn install:install-file -Dfile=clojure-lang.jar -DgroupId=org.clojure -DartifactId=clojure-lang -Dversion=1.1.0-alpha-SNAPSHOT -Dpackaging=jar
</code></p>

<p>Do the same for clojure-contrib.</p>

<p>You can also create a directory in under your project root and have pom.xml looking for artifacts in that directory as well. I found this to be useful for artifacts that are not in the central repository. To do so, add repository definition in pom.xml:</p>

<p>```xml
<repositories></p>

<pre><code>&lt;repository&gt;
    &lt;id&gt;lib-repo&lt;/id&gt;
    &lt;name&gt;lib-m2-repository&lt;/name&gt;
    &lt;url&gt;file://${basedir}/lib-repo&lt;/url&gt;
    &lt;layout&gt;legacy&lt;/layout&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/snapshots&gt;
    &lt;releases&gt;
        &lt;checksumPolicy&gt;ignore&lt;/checksumPolicy&gt;
    &lt;/releases&gt;
&lt;/repository&gt;
</code></pre>

<p></repositories>
```</p>

<p>Afterwards, you need to setup your directory structure as follows:
```
${project_root}
-- lib-repo</p>

<pre><code>-- org.clojure
    -- jars
        * clojure-lang-1.1.0-alpha-SNAPSHOT.jar
        * clojure-contrib-1.1.0-alpha-SNAPSHOT.jar
    -- poms
        * clojure-lang-1.1.0-alpha-SNAPSHOT.pom
        * clojure-contrib-1.1.0-alpha-SNAPSHOT.pom
</code></pre>

<p>```</p>

<p>The pom files can be found in your local repository after you’ve done <code>mvn install:install-file</code>.</p>

<p>If you want to run <code>clojure:repl</code> goal, you’d better add jline to your dependency as well:</p>

<p>```xml
<dependencies>
  ...</p>

<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;jline&lt;/groupId&gt;
        &lt;artifactId&gt;jline&lt;/artifactId&gt;
        &lt;version&gt;0.9.94&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>

<p>  ...
</dependencies>
```</p>

<p>By convention, the plugin compiles everything under <code>${project\_root}/src/main/clojure</code> and <code>${project\_root}/src/test/clojure</code>.</p>

<p>It’s hard to imagine working in a language like Clojure without automated unit tests. Fortunately, clojure-maven-plugin has the <code>clojure:test</code> goal which runs unit tests. All you need to do is telling the plugin where’s the entry point of your unit test. Add the following configuration in the build section:</p>

<p>```xml
<build></p>

<pre><code>&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;com.theoryinpractise&lt;/groupId&gt;
        &lt;artifactId&gt;clojure-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;
        &lt;configuration&gt;
            &lt;testScript&gt;src/test/clojure/pci/test.clj&lt;/testScript&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p></build>
```</p>

<p>The test script looks like the following:
```clojure
(ns my-namespace
  (:use clojure.contrib.test-is</p>

<pre><code>      test-module-1
      test-module-2))
</code></pre>

<p>(run-tests 'test-module-n)
```</p>

<p>There you have it! The sample files can be found in my <a href="http://github.com/kevinjqiu/pci-clj">pci-clj</a> project on GitHub.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Collective Intelligence in Clojure]]></title>
    <link href="http://kevinjqiu.github.com/2009/11/10/programming-collective-intelligence-in-clojure/"/>
    <updated>2009-11-10T11:08:00-05:00</updated>
    <id>http://kevinjqiu.github.com/2009/11/10/programming-collective-intelligence-in-clojure</id>
    <content type="html"><![CDATA[<p>They say the best way to learn a new programming language is by programming in it. Therefore I’m starting this project converting algorithms in the book <a href="http://oreilly.com/catalog/9780596529321">Programming Collective Intelligence</a> into Clojure, while learning the best practices and language idioms during the process.</p>

<p>I’ve created a GitHub <a href="http://github.com/kevinjqiu/pci-clj">project</a> for this. I’m not sure how far I’m able to go but let’s see.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Explore Clojure: Building a Bifid cipher]]></title>
    <link href="http://kevinjqiu.github.com/2009/10/20/explore-clojure-building-a-bifid-cipher/"/>
    <updated>2009-10-20T00:00:00-04:00</updated>
    <id>http://kevinjqiu.github.com/2009/10/20/explore-clojure-building-a-bifid-cipher</id>
    <content type="html"><![CDATA[<p>Lately I’ve been teaching myself <a href="http://clojure.org">Clojure</a>, a Lisp dialect on the JVM platform. I still love Erlang and still learning it, but Clojure has a special draw for me being a JVM language and its Lisp roots. I studied Scheme (another Lisp dialect) in my college years and deemed it purely academic. However, Clojure has the potential of changing this and bring the expressiveness of Lisp and the power of functional programming to the Java world.</p>

<p>The best way to learn a language is to use it to solve some non-trivial practical problems. I stumbled <a href="http://programmingpraxis.com/2009/10/13/bifid-cipher/">this</a> problem on <a href="http://programmingpraxis.com/">Programming Praxis</a>. It’s about building a <a href="http://en.wikipedia.org/wiki/Bifid_cipher">Bifid</a> cipher, which I thought could be a good practical problem for me to solve in Clojure.</p>

<h2>Polybius Square</h2>

<p>Bifid cipher is based on <a href="http://en.wikipedia.org/wiki/Polybius_square">Polybius Square</a>, which looks like this:</p>

<p><code>
  1 2 3 4 5
1 B G W K Z
2 Q P N D S
3 I O A X E
4 F C L U M
5 T H Y V R
</code></p>

<p>Every encodable letter is given a vector value, which is the coordinate in this square. For example, <code>X=[3 4]</code>, <code>H=[5 2]</code>. The first task would be building the Polybius square in Clojure.</p>

<p>My function <code>polybius-square</code> is going to take 2 parameters: <code>charset</code> is a list of encodable characters, and <code>size</code> is the size of the Polybius square.</p>

<p>```clojure
(defn polybius-square
  "Polybius square by the given charset and size"
  [charset square-size]
  (map #(vector %1 [%2 %3]) charset</p>

<pre><code>(for [x (range 1 (+ 1 square-size)), y (range 1 (+ 1 square-size))] x)
(take (* square-size square-size) (cycle (range 1 (+ 1 square-size))))))
</code></pre>

<p>```</p>

<p>Let’s see how this works. Suppose you’re calling this function with
<code>(polybius-square "ABCDE" 3)</code>, <code>charset</code> is bound to “ABCDE” and <code>size</code> is bound to 3. What I want is a seq of vectors in the form of: <code>(\Letter [x y])</code> where <code>x</code> and <code>y</code> are the coordinates. It’s natural to use <code>map</code>, with the function-to-map taking three parameters and vectorize them. That’s what the anonymous function does:</p>

<p>```clojure</p>

<h1>(vector %1 [%2 %3])</h1>

<p>```</p>

<p><code>%1</code> is the letter, <code>%2</code> and <code>%3</code> are the coordinates. I want the coordinate sequence to be like this: <code>[1 1], [1 2], [1 3], [2 1], [2 2], [2 3]</code>. In imperative language, you’d use a nested for loop, but we’ve established that’s ugly. We want the parameters fed to map to be of the following:
<code>"ABCDEFGHJI" (1 1 1 2 2 2 3 3 3) (1 2 3 1 2 3 1 2 3 1 2 3)</code></p>

<p>To generate the first list, we use list comprehension:</p>

<p><code>clojure
(for [ x (range 1 (+ 1 square-size)), y (range 1 (+ 1 square-size))] x)
</code></p>

<p>It reads: for every <code>x</code> in range 1 to <code>square-size</code>+1 (because “range” is right-exclusive) and for every <code>y</code> in the same range, output the value of <code>x</code> and take the whole output as the list. Because the binding of <code>y</code> comes later, and Lisp evaluates from right to left, the result of this list comprehension is <code>(1 1 1 2 2 2 3 3 3)</code></p>

<p>Now let’s look at the other list: <code>(1 2 3 1 2 3 1 2 3)</code> – a cyclic list. Fortunately, Clojure has a built-in <code>cycle</code> function, which returns a lazy sequence of cycles of a collection. We want to call it with cycle <code>'(1 2 3)</code>, so it’s going to be <code>(cycle (range 1 (+ 1 square-size)))</code>. Because cycle will be evaluated to an infinite sequence, we have to tell it when to stop.</p>

<p>When you see the square as a flat list, it’s clear that the cycle should stop when it reaches <code>square-size^2</code>, hence <code>(take (\* square-size square-size) (cycle (range 1 (+ 1 square-size))))</code>.</p>

<h2>The codec maps</h2>

<p>After the Polybius square is built, we have the bases for our encryption. However, it’s not user-friendly: it’s a flat list of tuples. We want two maps for fast searching from letters to their encoding forms <code>(letter-2-code)</code> and from transposed vectors to the letters <code>(transposed-2-letter)</code>.</p>

<p>```clojure
(defn- letter-2-code
  "Produce a mapping between letters and their codes"
  [square]
  (letfn [(helper [the-square the-map]</p>

<pre><code>      (if (empty? the-square)
        the-map
        (let [the-item (first the-square)
              the-key (first the-item)
              the-number (second the-item)]
          (recur (rest the-square) (assoc the-map the-key the-number)))))]
(helper square (empty hash-map))))
</code></pre>

<p>```</p>

<p>The strategy here is to walk through the list, add each item to a <code>hash-map</code>. Here we define an inner function, which is basically a recursive helper. The function itself is pretty straightforward. Take note that in Clojure, when you need to do tail recursion, always use <code>recur</code> instead of calling the function by its name. This is because JVM cannot do automatic tail cut optimization (TCO), but Clojure does the optimization through the <code>recur</code> function. After the binding, we kick off the recursion by calling it with the initial list.</p>

<p>In the similar fashion, we have:</p>

<p>```clojure
(defn- transposed-2-letter
  "Produce a mapping between the transposed codes to letter"
  [square]
  (letfn [(helper [the-square the-map]</p>

<pre><code>        (if (empty? the-square)
          the-map
          (let [the-item (first the-square)
                the-key (second the-item)
                the-letter (first the-item)]
            (recur (rest the-square) (assoc the-map the-key the-letter)))))]
(helper square (empty hash-map))))
</code></pre>

<p>```</p>

<h2>Encode</h2>

<p>Now comes the <code>encode</code> function. It’s important to note that the encoding will be different if a different polybius square is provided. Therefore, both <code>encode</code> and <code>decode</code> functions take the Polybius square as parameter.</p>

<p>During the encoding phase, we first convert every character in the message into a vector, then reorganize the vectors. To better illustrate, we use an example:
Suppose we have the following mapping:
<code>{I [3 3], H [3 2], G [3 1], F [2 3], E [2 2], D [2 1], C [1 3], B [1 2], A [1 1]}</code>
and we want to encode the word “CEDE”
<code>CEDE =&gt; ([1 3] [2 2] [2 1] [2 2])</code>, then we want to transpose the “matrix” composed of the above vectors, so it would be like:
<code>([1 2] [2 2] [3 2] [1 2])</code>, and finally looking up every item in the transposed-2-letter mapping</p>

<p><code>
{[3 3] I, [3 2] H, [3 1] G, [2 3] F, [2 2] E, [2 1] D, [1 3] C, [1 2] B, [1 1] A}
=&gt;BEHB
</code></p>

<p>To get a mapping of message to vectors, we again map a function to the list:
<code>(map #(get l2c % %) message)</code> (l2c has been bound)</p>

<p>Then we apply the interleave function to the result, this gives:
<code>(1 2 2 2 3 2 1 2)</code>. This is good but we want a list of vectors instead of a flat list. Clojure provides partition function, which does exactly it:
<code>(partition 2 '(1 2 2 2 3 2 1 2))</code>
gives:
<code>([1 2] [2 2] [3 2] [1 2])</code></p>

<p>Then, we want to lookup every item in the result in the <code>transposed-to-letter</code> map and get a list of mapped characters. To achieve this, again, we use map, providing a different mapping:
<code>(map #(get tr2l % %) ...)</code> (tr2l is bound)</p>

<p>This returns a list of characters. We want a string, so we concatenate the characters by applying <code>str</code> function:
<code>(apply str (map #(get tr2l % %) ...))</code></p>

<p>Here’s the complete code:</p>

<p>```clojure
(defn encode
  "Return the message encoded by the specified polybius-square"
  [message polybius-square]
  (let [l2c (letter-2-code polybius-square)</p>

<pre><code>    tr2l (transposed-2-letter polybius-square)]
(apply str
  (map #(get tr2l % %) (partition 2 (apply interleave (map #(get l2c % %) message)))))))
</code></pre>

<p>```</p>

<p>Here you see the expressiveness of Clojure: all operations are chained together and formed in expression.</p>

<p>The <code>decode</code> function behaves similarly. The only trick is we need to split the translated code list in two. We use <code>partition</code> method again, with <code>size</code> being half of the entire list.</p>

<p>```clojure
(defn decode
  "Return the decoded message using the specified polybius-square"
  [encoded polybius-square]
  (let [l2c (letter-2-code polybius-square)</p>

<pre><code>    c2l (transposed-2-letter polybius-square)
    codes (apply concat (map #(get l2c % %) encoded))
    len (count codes)
    parts (partition (/ len 2) codes)]
(apply str (map #(get c2l %1 %1) (map #(vector %1 %2) (first parts) (second parts))))))
</code></pre>

<p>```</p>

<h2>Putting it together</h2>

<p>Now with all the pieces are in place, we can put it together by writing a simple test:
```clojure
(defn -main
  "A simple test case entry point"
  []
  (let [square (polybius-square "ABCDEFGHIKLMNOPQRSTUVWXYZ" 5)]</p>

<pre><code>(do (println (encode "BIFIDCIPHER" square))
  (println (decode (encode "BIFIDCIPHER" square) square)))))
</code></pre>

<p>```</p>

<p>Output:</p>

<p>BGAHFRQTOXW
BIFIDCIPHER</p>

<p>Have the complete source code <a href="http://github.com/kevinjqiu/bifid-clj">here</a>, I’m sure there are a lot to be improved of the above implementation of the Bifid cipher. Especially currently I have no elegant way to solve the situation where the letter to be encoded is not in the Polybius square. Also, I’m sure my code isn’t entirely the idiomatic Clojure. If you have any suggestions, don’t hesitate to write a comment.</p>

<p>Although I have been learning Clojure for 3 days, I’m already enjoying its expressiveness and the clean look. As a Java programmer, Clojure also gives me the benefit of full access to the Java land. The potential is endless!</p>
]]></content>
  </entry>
  
</feed>
